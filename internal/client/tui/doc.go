// Package tui реализует текстовый пользовательский интерфейс (TUI) для клиента GophKeeper.
//
// # Общая идея
//
// Пакет реализует TUI-клиент поверх Bubble Tea. Пользователь работает
// с «сущностями» (логины, заметки, банковские карты, файлы и т.п.) через
// унифицированные экраны списка и редактирования. Долгие операции (например,
// загрузка/скачивание файлов) показывают прогресс и поддерживают отмену.
//
// Основные зависимости
//
//   - github.com/charmbracelet/bubbletea — цикл сообщений/модель состояния.
//   - github.com/charmbracelet/lipgloss — оформление/стили.
//   - github.com/charmbracelet/bubbles — виджеты (progress, textarea, textinput и др.).
//
// Архитектура и жизненный цикл
//
//   - Центральная структура Model — единый источник истины (state machine).
//     Она хранит текущий screen/state, ссылку на сервисы данных и локальный UI-стейт.
//   - Каждый экран оформлен тройкой функций в одном стиле:
//     initXxxForm(m, ...), updateXxx(m, msg), renderXxx(m)
//     и подключается через switch по m.currentState в Model.Update/View.
//   - Переходы между экранами выполняются установкой m.prevState/m.currentState
//     (без стека экранов) либо через вспомогательные init-функции.
//
// Экраны/состояния (не исчерпывающий список)
//
//   - "login" / "register" — аутентификация пользователя.
//   - "menu"                 — главное меню приложения.
//   - "list"                 — список записей выбранного типа (TypeLogins, …, TypeFiles).
//   - "edit"                 — универсальная форма создания/редактирования записи.
//   - "fullscreen_editor"    — полноэкранный редактор больших текстов/заметок.
//   - "file_transfer"        — форма передачи файлов (upload/download) с прогресс-баром
//     и отменой.
//
// # Сервисы и контракты
//
// Пакет не знает конкретных реализаций хранилища — он работает через слой contracts.
//
//   - DataService — общий CRUD-интерфейс для любого типа записи.
//     Model держит services: map[contracts.DataType]contracts.DataService.
//   - Для файлов может быть расширение адаптера:
//     BinaryTransferCapable { UploadBinaryData(ctx, *model.BinaryData, path string, progress chan<- int64) error
//     DownloadBinaryData(ctx, id, dest string, progress chan<- int64) error }
//     Один и тот же адаптер может реализовать и DataService (для списка/редактора),
//     и BinaryTransferCapable (для передачи), чтобы TUI не знал о конкретном сервисе.
//
// # Долгие операции и прогресс
//
// Для фоновых задач используется каноничный паттерн Bubble Tea:
//
//   - Фоновая горутина делает работу и пишет кумулятивный прогресс в chan int64.
//   - В UI подписка оформлена как tea.Cmd:
//     tea.Batch(listenProgressThrottle(ch, 200*time.Millisecond), waitDone(doneCh))
//     где listenProgressThrottle коалесцирует значения за окно (снижает «шум»),
//     а скорость сглаживается EWMA: v = α*inst + (1-α)*v.
//   - Отмена осуществляется через context.CancelFunc; сервис обязан корректно
//     закрыть progress-канал и вернуть ошибку/статус.
//
// Горячие клавиши (общие соглашения)
//
//   - Enter — подтвердить/старт операции.
//   - Esc / Ctrl+C — назад/отмена текущей операции.
//   - Tab — переключение режима/фокуса, если применимо.
//   - Для файлов (если экран "file_transfer" подключён):
//     Ctrl+U — открыть загрузку на сервер (upload),
//     Ctrl+D — открыть скачивание с сервера (download; доступно, если есть ClientPath).
//
// # Стили
//
// Общие стили хранятся в styles.go (заголовки, подсказки, ошибки и т.д.) и
// используются во всех экранах для единообразного оформления.
//
// Расширение: добавление нового типа данных
//
//  1. Реализуйте адаптер, удовлетворяющий contracts.DataService.
//  2. Зарегистрируйте его в Model.services по соответствующему DataType.
//  3. При необходимости добавьте специализированные экраны/виджеты:
//     initMyTypeForm/updateMyType/renderMyType.
//  4. Для файловых сценариев можно реализовать BinaryTransferCapable в адаптере,
//     чтобы автоматически включить экран передачи файлов.
//
// # Пример запуска
//
// Конкретные точки входа (main/runner) находятся в runner.go. Как правило,
// приложение создаёт Model, передаёт набор сервисов и запускает tea.Program.
// См. runner.go и соответствующий конструктор/инициализацию модели.
//
// Конвенции именования
//
//   - initXxxForm — инициализация экрана (установка currentState/prevState и UI-поля).
//   - updateXxx   — обработчик сообщений конкретного экрана.
//   - renderXxx   — отрисовка экрана.
//
// Пакет предназначен для использования из исполняемого модуля (cmd/*) и не
// содержит сетевой/бизнес-логики: она инкапсулирована в сервисах (contracts/*).
package tui
